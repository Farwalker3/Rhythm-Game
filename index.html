<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>MIDI Groove</title>
    <link rel="icon" href="favicon.svg" type="image/svg+xml">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/tone@14.7.77/build/Tone.js"></script>
    <script src="https://unpkg.com/@tonejs/midi"></script>

    <style>
        :root {
            --bg-color: #e0e5ec;
            --primary-color: #8a9bff;
            --shadow-light: #ffffff;
            --shadow-dark: #a3b1c6;
            --text-color: #5a6779;
            --note-colors: #ff8a80, #ffb347, #ffea00, #8cff80, #80d8ff, #8a9bff, #d380ff;
            --note-border-radius: 15px;
            --note-height: 25px;
            --note-width: 80%;
        }

        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            overflow: hidden;
            -webkit-tap-highlight-color: transparent;
        }

        .game-container {
            width: 100%;
            max-width: 480px;
            height: 100vh;
            max-height: 900px;
            background-color: var(--bg-color);
            border-radius: 30px;
            box-shadow: 12px 12px 24px var(--shadow-dark), -12px -12px 24px var(--shadow-light);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 25px;
            box-sizing: border-box;
            position: relative;
        }

        .header {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding: 0 10px;
        }
        
        .header-center {
            text-align: center;
            flex-grow: 1;
        }

        h1 {
            font-size: 2.5rem;
            margin: 0;
            font-weight: 700;
            color: var(--primary-color);
            text-shadow: 1px 1px 2px var(--shadow-light);
        }
        
        .song-title {
            height: 20px;
            margin-top: 5px;
            font-style: italic;
            opacity: 0.8;
            font-size: 0.9rem;
        }

        .game-screen {
            width: 100%;
            flex-grow: 1;
            background-color: var(--bg-color);
            border-radius: 20px;
            box-shadow: inset 8px 8px 16px var(--shadow-dark), inset -8px -8px 16px var(--shadow-light);
            position: relative;
            overflow: hidden;
        }

        .note-lane {
            position: absolute;
            bottom: 0;
            width: 25%;
            height: 100%;
            border-right: 2px solid rgba(163, 177, 198, 0.3);
            box-sizing: border-box;
        }
        .note-lane:last-child { border-right: none; }
        .note-lane:nth-child(1) { left: 0%; }
        .note-lane:nth-child(2) { left: 25%; }
        .note-lane:nth-child(3) { left: 50%; }
        .note-lane:nth-child(4) { left: 75%; }

        .note {
            position: absolute;
            width: var(--note-width);
            height: var(--note-height);
            left: 50%;
            transform: translateX(-50%) translateY(var(--note-y-pos, 0px));
            background-color: var(--primary-color);
            border-radius: var(--note-border-radius);
            box-shadow: 4px 4px 8px var(--shadow-dark), -4px -4px 8px var(--shadow-light);
        }

        .hit-zone {
            position: absolute;
            bottom: 10%;
            width: 100%;
            height: 40px;
            display: flex;
        }

        .key-target {
            width: 25%;
            height: 100%;
            border-radius: 15px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 1.2rem;
            transition: all 0.05s ease;
        }

        .key-target.active {
            box-shadow: inset 4px 4px 8px var(--shadow-dark), inset -4px -4px 8px var(--shadow-light);
            transform: scale(0.98);
        }

        .hit-feedback {
            position: absolute;
            bottom: 15%;
            left: 50%;
            transform: translateX(-50%);
            font-size: 2rem;
            font-weight: bold;
            opacity: 0;
            transition: all 0.3s ease;
            text-shadow: 2px 2px 4px var(--shadow-dark);
        }

        .score-display, .combo-display {
            position: absolute;
            top: 15px;
            font-size: 1.5rem;
            font-weight: bold;
        }
        .score-display { right: 25px; }
        .combo-display { left: 25px; }

        .controls {
            width: 100%;
            margin-top: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .neumorphic-btn, .icon-btn {
            border: none;
            border-radius: 15px;
            background: var(--bg-color);
            box-shadow: 6px 6px 12px var(--shadow-dark), -6px -6px 12px var(--shadow-light);
            color: var(--text-color);
            cursor: pointer;
            transition: all 0.1s ease-in-out;
        }
        .neumorphic-btn[disabled] {
            opacity: 0.5;
            cursor: not-allowed;
            box-shadow: inset 6px 6px 12px var(--shadow-dark), inset -6px -6px 12px var(--shadow-light);
        }

        .neumorphic-btn {
            padding: 15px 25px;
            font-size: 1rem;
            font-weight: bold;
            margin: 0 10px;
        }
        .icon-btn {
            width: 45px;
            height: 45px;
            font-size: 1.5rem;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 50%;
        }

        .neumorphic-btn:hover:not([disabled]), .icon-btn:hover:not([disabled]) { color: var(--primary-color); }
        .neumorphic-btn:active:not([disabled]), .icon-btn:active:not([disabled]) {
            box-shadow: inset 6px 6px 12px var(--shadow-dark), inset -6px -6px 12px var(--shadow-light);
            transform: scale(0.98);
        }
        
        input[type="file"] { display: none; }

        .modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(224, 229, 236, 0.9);
            border-radius: 30px;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            text-align: center;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        .modal.visible { opacity: 1; pointer-events: auto; }
        
        .modal-content {
            background: var(--bg-color);
            padding: 30px 40px;
            border-radius: 20px;
            box-shadow: 12px 12px 24px var(--shadow-dark), -12px -12px 24px var(--shadow-light);
            min-width: 300px;
            max-width: 90%;
        }
        .modal h2 { font-size: 2rem; margin-bottom: 20px; }
        .modal p { font-size: 1.2rem; margin-bottom: 20px; }
        
        .settings-item, .song-list-item {
            margin-bottom: 20px;
            text-align: left;
        }
        .settings-item label {
            display: block;
            margin-bottom: 10px;
            font-weight: bold;
        }
        select, input[type="range"] {
            width: 100%;
            padding: 10px;
            border-radius: 10px;
            border: none;
            background: var(--bg-color);
            box-shadow: inset 4px 4px 8px var(--shadow-dark), inset -4px -4px 8px var(--shadow-light);
            font-family: 'Inter', sans-serif;
            color: var(--text-color);
        }
        
        #difficulty-selection {
            display: flex;
            flex-direction: row;
            justify-content: center;
            gap: 15px;
        }
        #song-list {
            max-height: 40vh;
            overflow-y: auto;
            width: 100%;
            padding-right: 15px;
        }
        
        #pause-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(5px);
            z-index: 50;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 20px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
        }
        #pause-overlay.visible {
            opacity: 1;
            pointer-events: auto;
        }
    </style>
</head>
<body>

    <div class="game-container">
        <div class="header">
            <button id="pause-btn" class="icon-btn" style="visibility: hidden;">❚❚</button>
            <div class="header-center">
                <h1>MIDI Groove</h1>
                <p class="song-title">Upload a MIDI file to start</p>
            </div>
            <button id="settings-btn" class="icon-btn">⚙️</button>
        </div>
        
        <div class="game-screen">
            <div class="note-lane" data-lane="0"></div>
            <div class="note-lane" data-lane="1"></div>
            <div class="note-lane" data-lane="2"></div>
            <div class="note-lane" data-lane="3"></div>
            <div class="hit-zone">
                <div class="key-target" data-lane="0">D</div>
                <div class="key-target" data-lane="1">F</div>
                <div class="key-target" data-lane="2">J</div>
                <div class="key-target" data-lane="3">K</div>
            </div>
            <div class="score-display">0</div><div class="combo-display"></div><div class="hit-feedback"></div>
            
            <div id="pause-overlay">
                <button id="resume-btn" class="neumorphic-btn">Resume</button>
                <button id="restart-btn" class="neumorphic-btn">Restart Song</button>
                <button id="change-difficulty-btn" class="neumorphic-btn">Change Difficulty</button>
                <button id="restart-checkpoint-btn" class="neumorphic-btn" style="display:none;">Restart from Checkpoint</button>
                <button id="main-menu-btn" class="neumorphic-btn">Main Menu</button>
            </div>
        </div>
        
        <div class="controls">
            <label for="midi-upload" id="file-upload-label" class="neumorphic-btn">Upload MIDI</label>
            <button id="library-btn" class="neumorphic-btn">Song Library</button>
        </div>
        <input type="file" id="midi-upload" accept=".mid,.midi">
        
        <div id="settings-modal" class="modal">
            <div class="modal-content">
                <h2>Settings</h2>
                <div class="settings-item">
                    <label for="track-select">Gameplay Track</label>
                    <select id="track-select"></select>
                </div>
                <div class="settings-item">
                    <label for="note-speed-slider">Note Speed</label>
                    <input type="range" id="note-speed-slider" min="100" max="800" value="300" step="25">
                </div>
                <div class="settings-item">
                    <label for="volume-slider">Volume</label>
                    <input type="range" id="volume-slider" min="-40" max="6" value="-6" step="1">
                </div>
                <div class="settings-item">
                    <label for="hit-tolerance-slider">Hit Tolerance (100% = Normal)</label>
                    <input type="range" id="hit-tolerance-slider" min="50" max="200" value="100" step="10">
                </div>
                <div class="settings-item">
                    <label for="theme-select">Theme</label>
                    <select id="theme-select">
                        <option value="pastel">Pastel Dream</option>
                        <option value="ocean">Ocean Deep</option>
                        <option value="sunset">Sunset</option>
                        <option value="forest">Forest</option>
                        <option value="neon">Neon</option>
                        <option value="8bit">8-Bit</option>
                        <option value="mono">Monochrome</option>
                    </select>
                </div>
                <div class="settings-item">
                    <label for="note-style-select">Note Style</label>
                    <select id="note-style-select">
                        <option value="rounded">Rounded</option>
                        <option value="square">Square</option>
                        <option value="circle">Circle</option>
                        <option value="tile">Full Tile</option>
                    </select>
                </div>
                <button id="close-settings-btn" class="neumorphic-btn">Close</button>
            </div>
        </div>
        
        <div id="difficulty-modal" class="modal">
            <div class="modal-content">
                <h2>Select Difficulty</h2>
                <p id="difficulty-song-name"></p>
                <div id="difficulty-selection">
                    <button class="neumorphic-btn difficulty-btn" data-difficulty="easy">Easy</button>
                    <button class="neumorphic-btn difficulty-btn" data-difficulty="medium">Medium</button>
                    <button class="neumorphic-btn difficulty-btn" data-difficulty="hard">Hard</button>
                </div>
                 <button id="cancel-difficulty-btn" class="neumorphic-btn" style="margin-top: 20px;">Cancel</button>
            </div>
        </div>

        <div id="song-library-modal" class="modal">
            <div class="modal-content">
                <h2>Song Library</h2>
                <div id="song-list"></div>
                <button id="close-library-btn" class="neumorphic-btn" style="margin-top: 20px;">Close</button>
            </div>
        </div>

        <div id="results-modal" class="modal">
            <div class="modal-content">
                <h2>Game Over!</h2>
                <p id="final-score"></p><p id="final-accuracy"></p>
                <button id="play-again-btn" class="neumorphic-btn">Play Again</button>
            </div>
        </div>
    </div>

    <script>
        // --- Global Scope Variables ---
        let NOTE_COLORS = [];
        const GAME_STATES = { IDLE: 0, LOADING: 1, PLAYING: 2, PAUSED: 3, RESULTS: 4 };
        let gameState = GAME_STATES.IDLE;
        let score = 0, combo = 0, totalNotes = 0, notesHit = 0;
        let midiData = null;
        let notesOnScreen = [], gameChart = {}, checkpoints = [];
        let currentCheckpointIndex = -1;
        let chartCache = {};
        let recentHits = [];
        let dynamicHitMultiplier = 1.0;
        let manualHitMultiplier = 1.0;
        let liveSettingsUpdateTimer = null;
        let currentDifficulty = 'medium';
        
        const HIT_WINDOW_PERFECT = 0.08;
        const HIT_WINDOW_GOOD = 0.15;
        const NUM_LANES = 4;
        const LANE_KEYS = ['d', 'f', 'j', 'k'];
        let NOTE_SPEED = 300;
        const DIFFICULTY_SETTINGS = {
            easy: { minNoteInterval: 0.4 },
            medium: { minNoteInterval: 0.2 },
            hard: { minNoteInterval: 0.05 }
        };
        const THEMES = {
            pastel: {
                '--bg-color': '#e0e5ec', '--primary-color': '#8a9bff', '--shadow-light': '#ffffff',
                '--shadow-dark': '#a3b1c6', '--text-color': '#5a6779',
                '--note-colors': '#ff8a80, #ffb347, #ffea00, #8cff80, #80d8ff, #8a9bff, #d380ff'
            },
            ocean: {
                '--bg-color': '#2c3e50', '--primary-color': '#3498db', '--shadow-light': '#34495e',
                '--shadow-dark': '#212f3c', '--text-color': '#ecf0f1',
                '--note-colors': '#e74c3c, #f1c40f, #2ecc71, #3498db, #9b59b6, #1abc9c, #e67e22'
            },
            sunset: {
                '--bg-color': '#f2d1a7', '--primary-color': '#e67e22', '--shadow-light': '#f5e6c4',
                '--shadow-dark': '#d35400', '--text-color': '#4f2f2f',
                '--note-colors': '#c0392b, #d35400, #f39c12, #f1c40f, #27ae60, #2980b9, #8e44ad'
            },
            forest: {
                '--bg-color': '#3d402b', '--primary-color': '#94a656', '--shadow-light': '#52573a',
                '--shadow-dark': '#282a1c', '--text-color': '#e0e8c4',
                '--note-colors': '#e56b6f, #f4a261, #e9c46a, #2a9d8f, #264653, #8ecae6, #b1a7a6'
            },
            neon: {
                '--bg-color': '#1a1a1a', '--primary-color': '#00ffff', '--shadow-light': '#333333',
                '--shadow-dark': '#000000', '--text-color': '#ffffff',
                '--note-colors': '#ff00ff, #00ff00, #ffff00, #00ffff, #ff0000, #ff8c00, #ffffff'
            },
            '8bit': {
                '--bg-color': '#000000', '--primary-color': '#ffffff', '--shadow-light': '#222222',
                '--shadow-dark': '#000000', '--text-color': '#ffffff',
                '--note-colors': '#ff0000, #00ff00, #0000ff, #ffff00, #ff00ff, #00ffff, #ffffff'
            },
            mono: {
                '--bg-color': '#d1d1d1', '--primary-color': '#555555', '--shadow-light': '#ffffff',
                '--shadow-dark': '#a3a3a3', '--text-color': '#222222',
                '--note-colors': '#333333, #555555, #777777, #999999, #bbbbbb, #444444, #666666'
            }
        };
        const SONG_LIBRARY = [
            { name: "Alan Walker - Faded", url: "https://res.cloudinary.com/kodair/video/upload/v1752777995/Komidi/Alan_Walker-Faded_ytswpv.midi" },
            { name: "Alan Walker - Alone", url: "https://res.cloudinary.com/kodair/video/upload/v1752777995/Komidi/Alan_Walker-Alone_bqujfq.midi" },
            { name: "Alan Walker - Spectre", url: "https://res.cloudinary.com/kodair/video/upload/v1752777995/Komidi/Alan_Walker-Spectre_dyau6g.midi" }
        ];

        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM Elements ---
            const gameContainer = document.querySelector('.game-container');
            const gameScreen = document.querySelector('.game-screen');
            const scoreDisplay = document.querySelector('.score-display');
            const comboDisplay = document.querySelector('.combo-display');
            const hitFeedback = document.querySelector('.hit-feedback');
            const songTitle = document.querySelector('.song-title');
            const keyTargets = document.querySelectorAll('.key-target');
            const uploadInput = document.getElementById('midi-upload');
            const settingsBtn = document.getElementById('settings-btn');
            const pauseBtn = document.getElementById('pause-btn');
            const libraryBtn = document.getElementById('library-btn');
            const noteLanes = document.querySelectorAll('.note-lane');
            
            // Modals & Buttons
            const settingsModal = document.getElementById('settings-modal');
            const closeSettingsBtn = document.getElementById('close-settings-btn');
            const difficultyModal = document.getElementById('difficulty-modal');
            const difficultyBtns = document.querySelectorAll('.difficulty-btn');
            const difficultySongName = document.getElementById('difficulty-song-name');
            const cancelDifficultyBtn = document.getElementById('cancel-difficulty-btn');
            const pauseOverlay = document.getElementById('pause-overlay');
            const resultsModal = document.getElementById('results-modal');
            const songLibraryModal = document.getElementById('song-library-modal');
            const closeLibraryBtn = document.getElementById('close-library-btn');
            const songList = document.getElementById('song-list');
            const resumeBtn = document.getElementById('resume-btn');
            const restartBtn = document.getElementById('restart-btn');
            const changeDifficultyBtn = document.getElementById('change-difficulty-btn');
            const restartCheckpointBtn = document.getElementById('restart-checkpoint-btn');
            const mainMenuBtn = document.getElementById('main-menu-btn');
            const playAgainBtn = document.getElementById('play-again-btn');
            
            // Settings
            const trackSelect = document.getElementById('track-select');
            const noteSpeedSlider = document.getElementById('note-speed-slider');
            const volumeSlider = document.getElementById('volume-slider');
            const hitToleranceSlider = document.getElementById('hit-tolerance-slider');
            const themeSelect = document.getElementById('theme-select');
            const noteStyleSelect = document.getElementById('note-style-select');
            
            // Results
            const finalScoreEl = document.getElementById('final-score');
            const finalAccuracyEl = document.getElementById('final-accuracy');

            // --- Tone.js Setup ---
            const synth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { type: 'fmsine' },
                envelope: { attack: 0.01, decay: 0.1, sustain: 0.3, release: 1 },
            }).toDestination();
            Tone.Destination.volume.value = -6;


            // --- Event Listeners ---
            uploadInput.addEventListener('change', handleFileSelect);
            settingsBtn.addEventListener('click', () => settingsModal.classList.add('visible'));
            closeSettingsBtn.addEventListener('click', () => settingsModal.classList.remove('visible'));
            libraryBtn.addEventListener('click', () => songLibraryModal.classList.add('visible'));
            closeLibraryBtn.addEventListener('click', () => songLibraryModal.classList.remove('visible'));
            
            // Settings Listeners
            noteSpeedSlider.addEventListener('input', (e) => { NOTE_SPEED = parseInt(e.target.value); });
            volumeSlider.addEventListener('input', (e) => { Tone.Destination.volume.value = parseInt(e.target.value); });
            hitToleranceSlider.addEventListener('input', (e) => { manualHitMultiplier = parseInt(e.target.value) / 100; });
            themeSelect.addEventListener('change', (e) => applyTheme(e.target.value));
            noteStyleSelect.addEventListener('change', (e) => {
                applyNoteStyle(e.target.value);
                if(gameState === GAME_STATES.PAUSED) debounceLiveSettingsUpdate();
            });
            trackSelect.addEventListener('change', () => { if(gameState === GAME_STATES.PAUSED) debounceLiveSettingsUpdate(); });

            // Game Flow Listeners
            difficultyBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    const newDifficulty = btn.dataset.difficulty;
                    if (gameState === GAME_STATES.PAUSED) {
                        currentDifficulty = newDifficulty;
                        debounceLiveSettingsUpdate();
                        difficultyModal.classList.remove('visible');
                        pauseOverlay.classList.add('visible');
                    } else {
                        difficultyModal.classList.remove('visible');
                        startGame(newDifficulty);
                    }
                });
            });
            cancelDifficultyBtn.addEventListener('click', () => difficultyModal.classList.remove('visible'));
            pauseBtn.addEventListener('click', togglePause);
            resumeBtn.addEventListener('click', togglePause);
            restartBtn.addEventListener('click', () => { pauseOverlay.classList.remove('visible'); startGame(currentDifficulty); });
            changeDifficultyBtn.addEventListener('click', () => {
                pauseOverlay.classList.remove('visible');
                difficultyModal.classList.add('visible');
            });
            restartCheckpointBtn.addEventListener('click', restartFromCheckpoint);
            mainMenuBtn.addEventListener('click', goToMainMenu);
            playAgainBtn.addEventListener('click', () => {
                resultsModal.classList.remove('visible');
                startGame(currentDifficulty);
            });

            // Keyboard & Touch Listeners
            window.addEventListener('keydown', handleGlobalKeyPress);
            window.addEventListener('keyup', handleKeyRelease);
            document.querySelectorAll('.key-target').forEach(target => {
                target.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const lane = parseInt(e.target.dataset.lane);
                    processLaneHit(lane);
                    keyTargets[lane].classList.add('active');
                }, { passive: false });
                target.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    const lane = parseInt(e.target.dataset.lane);
                    keyTargets[lane].classList.remove('active');
                }, { passive: false });
            });


            // --- Core Functions ---
            
            function updateNoteColors() {
                 NOTE_COLORS = getComputedStyle(document.documentElement).getPropertyValue('--note-colors').split(',').map(c => c.trim());
            }

            function applyTheme(themeName) {
                const theme = THEMES[themeName];
                for (const [key, value] of Object.entries(theme)) {
                    document.documentElement.style.setProperty(key, value);
                }
                updateNoteColors();
            }

            function applyNoteStyle(styleName) {
                const root = document.documentElement;
                if (styleName === 'square') {
                    root.style.setProperty('--note-border-radius', '4px');
                    root.style.setProperty('--note-height', '25px');
                    root.style.setProperty('--note-width', '80%');
                } else if (styleName === 'circle') {
                    root.style.setProperty('--note-border-radius', '50%');
                    root.style.setProperty('--note-height', '40px');
                    root.style.setProperty('--note-width', '40px');
                } else if (styleName === 'tile') {
                    root.style.setProperty('--note-border-radius', '4px');
                    root.style.setProperty('--note-height', '25px');
                    root.style.setProperty('--note-width', '100%');
                } else { // rounded (default)
                    root.style.setProperty('--note-border-radius', '15px');
                    root.style.setProperty('--note-height', '25px');
                    root.style.setProperty('--note-width', '80%');
                }
            }

            function handleFileSelect(event) {
                if (gameState === GAME_STATES.LOADING) return;
                const file = event.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (e) => processMidiData(e.target.result, file.name);
                reader.readAsArrayBuffer(file);
            }

            async function loadSongFromUrl(song) {
                if (gameState === GAME_STATES.LOADING) return;
                setGameState(GAME_STATES.LOADING);
                songList.innerHTML = '<p>Loading...</p>';
                try {
                    const response = await fetch(song.url, { mode: 'cors' });
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    const arrayBuffer = await response.arrayBuffer();
                    processMidiData(arrayBuffer, song.name);
                    songLibraryModal.classList.remove('visible');
                } catch (error) {
                    console.error("Failed to load song:", error);
                    songList.innerHTML = `<p>Error loading song. CORS policy might be blocking the request.</p>`;
                    setTimeout(() => {
                        populateSongLibrary();
                        setGameState(GAME_STATES.IDLE);
                    }, 3000);
                }
            }

            function processMidiData(arrayBuffer, fileName) {
                 try {
                    midiData = new Midi(arrayBuffer);
                    populateTrackSelect();
                    difficultySongName.textContent = fileName.replace(/\.(mid|midi)$/i, '');
                    difficultyModal.classList.add('visible');
                    setGameState(GAME_STATES.IDLE);
                } catch (error) {
                    songTitle.textContent = "Invalid MIDI file!";
                    setGameState(GAME_STATES.IDLE);
                }
            }

            function populateTrackSelect() {
                trackSelect.innerHTML = '<option value="-1">Auto-Select Best Track</option>';
                midiData.tracks.forEach((track, index) => {
                    if (track.notes.length > 10) {
                        const option = document.createElement('option');
                        option.value = index;
                        option.textContent = `${index}: ${track.instrument.name} (${track.notes.length} notes)`;
                        trackSelect.appendChild(option);
                    }
                });
            }

            function populateSongLibrary() {
                songList.innerHTML = '';
                SONG_LIBRARY.forEach(song => {
                    const songBtn = document.createElement('button');
                    songBtn.className = 'neumorphic-btn song-list-item';
                    songBtn.textContent = song.name;
                    songBtn.onclick = () => loadSongFromUrl(song);
                    songList.appendChild(songBtn);
                });
            }

            function generateChart(midi, difficulty) {
                let bestTrack;
                const selectedTrackIndex = parseInt(trackSelect.value);
                if (selectedTrackIndex >= 0 && midi.tracks[selectedTrackIndex]) {
                    bestTrack = midi.tracks[selectedTrackIndex];
                } else {
                    const tracks = midi.tracks.filter(t => t.notes.length > 10).sort((a, b) => b.notes.length - a.notes.length);
                    const drumTrack = tracks.find(t => t.channel === 9);
                    bestTrack = drumTrack || tracks[0];
                }

                if (!bestTrack) return { chart: [], name: "No playable tracks" };

                const noteCounts = {};
                bestTrack.notes.forEach(n => { noteCounts[n.midi] = (noteCounts[n.midi] || 0) + 1; });
                const sortedNotes = Object.keys(noteCounts).sort((a, b) => noteCounts[b] - noteCounts[a]);
                const noteMap = new Map();
                sortedNotes.slice(0, NUM_LANES).forEach((midi, index) => noteMap.set(parseInt(midi), index));

                const initialChart = bestTrack.notes
                    .filter(note => noteMap.has(note.midi))
                    .map(note => ({ time: note.time, lane: noteMap.get(note.midi) }))
                    .sort((a, b) => a.time - b.time);

                const settings = DIFFICULTY_SETTINGS[difficulty];
                if (!settings) {
                    console.error("Invalid difficulty setting:", difficulty);
                    return { chart: [], name: "Error" };
                }
                const lastNoteTimeInLane = new Array(NUM_LANES).fill(-Infinity);
                const chart = initialChart.filter(note => {
                    if (note.time >= lastNoteTimeInLane[note.lane] + settings.minNoteInterval) {
                        lastNoteTimeInLane[note.lane] = note.time;
                        return true;
                    }
                    return false;
                });
                
                return { chart, name: bestTrack.instrument.name };
            }
            
            function generateCheckpoints(chart, duration) {
                if (duration < 90) return [];
                const checkpointTimes = [];
                for (let time = 60; time < duration - 30; time += 60) {
                    const closestNote = chart.reduce((prev, curr) => 
                        Math.abs(curr.time - time) < Math.abs(prev.time - time) ? curr : prev, {time: 0}
                    );
                    if(closestNote && closestNote.time > 0) checkpointTimes.push({ time: closestNote.time, score: 0, combo: 0, notesHit: 0 });
                }
                return checkpointTimes;
            }

            function updateCheckpoints() {
                const currentTime = Tone.Transport.seconds;
                const nextCheckpointIndex = currentCheckpointIndex + 1;
                if (nextCheckpointIndex < checkpoints.length && currentTime >= checkpoints[nextCheckpointIndex].time) {
                    currentCheckpointIndex = nextCheckpointIndex;
                    checkpoints[currentCheckpointIndex] = { ...checkpoints[currentCheckpointIndex], score, combo, notesHit };
                    restartCheckpointBtn.style.display = 'block';
                }
            }

            function restartFromCheckpoint() {
                if (currentCheckpointIndex < 0) return;
                const checkpoint = checkpoints[currentCheckpointIndex];
                score = checkpoint.score;
                combo = checkpoint.combo;
                notesHit = checkpoint.notesHit;
                scoreDisplay.textContent = score;
                updateCombo(combo);
                notesOnScreen.forEach(n => n.element.remove());
                notesOnScreen = [];
                Tone.Transport.seconds = checkpoint.time;
                togglePause();
            }

            async function startGame(difficulty = 'medium', startTime = 0) {
                if (!midiData || gameState === GAME_STATES.LOADING) return;
                
                await Tone.start();
                if(startTime === 0) resetGame();
                
                currentDifficulty = difficulty;
                const { chart, name } = generateChart(midiData, currentDifficulty);
                gameChart = chart;
                gameChart.difficulty = currentDifficulty;

                if (gameChart.length === 0) {
                    songTitle.textContent = "Could not generate a playable chart!";
                    return;
                }

                if(startTime === 0) {
                    checkpoints = generateCheckpoints(gameChart, midiData.duration);
                    currentCheckpointIndex = -1;
                    restartCheckpointBtn.style.display = 'none';
                }

                const originalTitle = difficultySongName.textContent;
                songTitle.textContent = `${originalTitle} (${name})`;
                totalNotes = gameChart.length;
                
                setGameState(GAME_STATES.PLAYING);
                
                Tone.Transport.cancel();
                midiData.tracks.forEach(track => {
                    track.notes.forEach(note => {
                        const duration = Math.max(0.01, note.duration);
                        Tone.Transport.scheduleOnce(time => synth.triggerAttackRelease(note.name, duration, time, note.velocity), note.time);
                    });
                });

                const futureNotes = gameChart.filter(note => note.time >= startTime);
                futureNotes.forEach(note => {
                    Tone.Draw.schedule(() => createNoteElement(note), note.time - (gameScreen.offsetHeight / NOTE_SPEED));
                });

                Tone.Transport.scheduleOnce(endGame, midiData.duration + 3);

                Tone.Transport.start(Tone.now(), startTime);
                gameLoop();
            }
            
            function debounceLiveSettingsUpdate() {
                clearTimeout(liveSettingsUpdateTimer);
                liveSettingsUpdateTimer = setTimeout(applyLiveSettingsChanges, 250);
            }

            function applyLiveSettingsChanges() {
                const resumeTime = Tone.Transport.seconds;
                
                // Clear upcoming visual notes
                Tone.Draw.cancel(resumeTime);
                notesOnScreen.forEach(note => {
                    if (note.time >= resumeTime) {
                        if (note.element) note.element.remove();
                    }
                });
                notesOnScreen = notesOnScreen.filter(note => note.time < resumeTime);

                // Regenerate chart with new settings
                const { chart, name } = generateChart(midiData, currentDifficulty);
                gameChart = chart;
                gameChart.difficulty = currentDifficulty;
                totalNotes = gameChart.length;

                // Reschedule future visual notes
                const futureNotes = gameChart.filter(note => note.time >= resumeTime);
                futureNotes.forEach(note => {
                    Tone.Draw.schedule(() => createNoteElement(note), note.time - (gameScreen.offsetHeight / NOTE_SPEED));
                });
                
                const originalTitle = difficultySongName.textContent;
                songTitle.textContent = `${originalTitle} (${name})`;
            }

            function togglePause() {
                if (gameState !== GAME_STATES.PLAYING && gameState !== GAME_STATES.PAUSED) return;
                
                if (gameState === GAME_STATES.PAUSED) { // RESUMING
                    debounceLiveSettingsUpdate(); // Apply any pending changes
                    setGameState(GAME_STATES.PLAYING);
                    Tone.Destination.mute = false;
                    Tone.Transport.start();
                    gameLoop();
                } else { // PAUSING
                    setGameState(GAME_STATES.PAUSED);
                    Tone.Destination.mute = true;
                    Tone.Transport.pause();
                }
            }
            
            function setGameState(newState) {
                gameState = newState;
                pauseOverlay.classList.toggle('visible', newState === GAME_STATES.PAUSED);
                settingsBtn.style.pointerEvents = (newState === GAME_STATES.PLAYING) ? 'none' : 'auto';
                pauseBtn.style.visibility = (newState === GAME_STATES.PLAYING || newState === GAME_STATES.PAUSED) ? 'visible' : 'hidden';
                
                const isIdle = newState === GAME_STATES.IDLE;
                libraryBtn.disabled = !isIdle;
                document.getElementById('file-upload-label').style.pointerEvents = isIdle ? 'auto' : 'none';
            }

            function shutdownGame() {
                Tone.Transport.stop();
                Tone.Transport.cancel();
                Tone.Destination.mute = false;
            }

            function endGame() {
                shutdownGame();
                setGameState(GAME_STATES.RESULTS);
                finalScoreEl.textContent = `Final Score: ${score}`;
                const accuracy = totalNotes > 0 ? ((notesHit / totalNotes) * 100).toFixed(2) : 0;
                finalAccuracyEl.textContent = `Accuracy: ${accuracy}%`;
                resultsModal.classList.add('visible');
            }

            function resetGame() {
                score = 0; combo = 0; notesHit = 0; totalNotes = 0;
                scoreDisplay.textContent = 0;
                comboDisplay.textContent = '';
                document.querySelectorAll('.note').forEach(n => n.remove());
                notesOnScreen = [];
                recentHits = [];
                dynamicHitMultiplier = 1.0;
            }

            function goToMainMenu() {
                shutdownGame();
                resetGame();
                resultsModal.classList.remove('visible');
                pauseOverlay.classList.remove('visible');
                songTitle.textContent = 'Upload a MIDI file to start';
                uploadInput.value = '';
                setGameState(GAME_STATES.IDLE);
            }

            function gameLoop() {
                if (gameState !== GAME_STATES.PLAYING) return;
                updateCheckpoints();

                const currentTime = Tone.Transport.seconds;
                const hitZoneTop = gameScreen.offsetHeight * 0.8; 

                notesOnScreen.forEach(note => {
                    if (note.hit) return;
                    const yPos = (currentTime - note.time) * NOTE_SPEED + hitZoneTop;
                    note.element.style.setProperty('--note-y-pos', `${yPos}px`);

                    if (yPos > gameScreen.offsetHeight) {
                        note.hit = true; 
                        if(note.element) note.element.style.display = 'none';
                        updateCombo(0); 
                        showFeedback('Miss', '#ff8a80');
                        updateDynamicTolerance(false);
                    }
                });

                notesOnScreen = notesOnScreen.filter(note => !note.hit || note.element.style.display !== 'none');
                requestAnimationFrame(gameLoop);
            }
            
            function createNoteElement(noteInfo) {
                const noteElement = document.createElement('div');
                noteElement.classList.add('note');
                noteElement.style.top = '-50px';
                noteElement.style.backgroundColor = NOTE_COLORS[noteInfo.lane % NOTE_COLORS.length];
                
                noteLanes[noteInfo.lane].appendChild(noteElement);

                noteInfo.element = noteElement;
                notesOnScreen.push(noteInfo);
            }

            function handleGlobalKeyPress(e) {
                if (e.code === 'Space' || e.code === 'Escape') {
                    e.preventDefault();
                    togglePause();
                }
                if (LANE_KEYS.includes(e.key)) {
                    processLaneHit(LANE_KEYS.indexOf(e.key));
                    keyTargets[LANE_KEYS.indexOf(e.key)].classList.add('active');
                }
            }
            
            function handleKeyRelease(e) {
                 if (LANE_KEYS.includes(e.key)) {
                    keyTargets[LANE_KEYS.indexOf(e.key)].classList.remove('active');
                 }
            }

            function processLaneHit(laneIndex) {
                if (gameState !== GAME_STATES.PLAYING) return;
                let bestNote = null;
                let smallestTimeDiff = Infinity;
                const currentTime = Tone.Transport.seconds;
                const combinedMultiplier = dynamicHitMultiplier * manualHitMultiplier;

                notesOnScreen.forEach(note => {
                    if (note.lane === laneIndex && !note.hit) {
                        const timeDiff = Math.abs(currentTime - note.time);
                        if (timeDiff < smallestTimeDiff) {
                            smallestTimeDiff = timeDiff;
                            bestNote = note;
                        }
                    }
                });

                if (bestNote && smallestTimeDiff <= (HIT_WINDOW_GOOD * combinedMultiplier)) {
                    processHit(bestNote, smallestTimeDiff <= (HIT_WINDOW_PERFECT * combinedMultiplier) ? 'Perfect' : 'Good');
                }
            }

            function processHit(note, rating) {
                note.hit = true;
                if(note.element) note.element.style.display = 'none';
                notesHit++;
                updateDynamicTolerance(true);
                const points = rating === 'Perfect' ? 100 : 50;
                const color = rating === 'Perfect' ? '#8cff80' : '#80d8ff';
                score += points + combo;
                updateCombo(combo + 1);
                showFeedback(rating, color);
                scoreDisplay.textContent = score;
            }
            
            function updateDynamicTolerance(hit) {
                recentHits.push(hit ? 1 : 0);
                if (recentHits.length > 20) {
                    recentHits.shift();
                }

                if (recentHits.length < 10) return;

                const hitRate = recentHits.reduce((a, b) => a + b, 0) / recentHits.length;
                
                if (hitRate < 0.5) {
                    dynamicHitMultiplier = 1.5; // Very lenient
                } else if (hitRate < 0.7) {
                    dynamicHitMultiplier = 1.2; // Slightly lenient
                } else {
                    dynamicHitMultiplier = 1.0; // Normal
                }
            }

            function updateCombo(newCombo) {
                combo = newCombo;
                comboDisplay.textContent = combo > 2 ? `${combo} Combo` : '';
            }

            function showFeedback(text, color) {
                hitFeedback.textContent = text;
                hitFeedback.style.color = color;
                hitFeedback.style.opacity = 1;
                hitFeedback.style.transform = 'translateX(-50%) scale(1.2)';
                setTimeout(() => {
                    hitFeedback.style.opacity = 0;
                    hitFeedback.style.transform = 'translateX(-50%) scale(1)';
                }, 300);
            }

            // Initial setup
            updateNoteColors();
            populateSongLibrary();
        });
    </script>
</body>
</html>