<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>MIDI Groove</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/tone@14.7.77/build/Tone.js"></script>
    <script src="https://unpkg.com/@tonejs/midi"></script>

    <style>
        :root {
            --bg-color: #e0e5ec;
            --primary-color: #8a9bff;
            --shadow-light: #ffffff;
            --shadow-dark: #a3b1c6;
            --text-color: #5a6779;
            --note-colors: #ff8a80, #ffb347, #ffea00, #8cff80, #80d8ff, #8a9bff, #d380ff;
            --note-border-radius: 15px;
        }

        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            overflow: hidden;
            -webkit-tap-highlight-color: transparent;
        }

        .game-container {
            width: 100%;
            max-width: 480px;
            height: 100vh;
            max-height: 900px;
            background-color: var(--bg-color);
            border-radius: 30px;
            box-shadow: 12px 12px 24px var(--shadow-dark), -12px -12px 24px var(--shadow-light);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 25px;
            box-sizing: border-box;
            position: relative;
        }

        .header {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding: 0 10px;
        }
        
        .header-center {
            text-align: center;
            flex-grow: 1;
        }

        h1 {
            font-size: 2.5rem;
            margin: 0;
            font-weight: 700;
            color: var(--primary-color);
            text-shadow: 1px 1px 2px var(--shadow-light);
        }
        
        .song-title {
            height: 20px;
            margin-top: 5px;
            font-style: italic;
            opacity: 0.8;
            font-size: 0.9rem;
        }

        .game-screen {
            width: 100%;
            flex-grow: 1;
            background-color: var(--bg-color);
            border-radius: 20px;
            box-shadow: inset 8px 8px 16px var(--shadow-dark), inset -8px -8px 16px var(--shadow-light);
            position: relative;
            overflow: hidden;
        }

        .note-lane {
            position: absolute;
            bottom: 0;
            width: 25%;
            height: 100%;
            border-right: 2px solid rgba(163, 177, 198, 0.3);
            box-sizing: border-box;
        }
        .note-lane:last-child { border-right: none; }
        .note-lane:nth-child(1) { left: 0%; }
        .note-lane:nth-child(2) { left: 25%; }
        .note-lane:nth-child(3) { left: 50%; }
        .note-lane:nth-child(4) { left: 75%; }

        .note {
            position: absolute;
            width: 80%;
            left: 10%;
            height: 25px;
            background-color: var(--primary-color);
            border-radius: var(--note-border-radius);
            box-shadow: 4px 4px 8px var(--shadow-dark), -4px -4px 8px var(--shadow-light);
        }

        .hit-zone {
            position: absolute;
            bottom: 10%;
            width: 100%;
            height: 40px;
            display: flex;
        }

        .key-target {
            width: 25%;
            height: 100%;
            border-radius: 15px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 1.2rem;
            transition: all 0.05s ease;
        }

        .key-target.active {
            box-shadow: inset 4px 4px 8px var(--shadow-dark), inset -4px -4px 8px var(--shadow-light);
            transform: scale(0.98);
        }

        .hit-feedback {
            position: absolute;
            bottom: 15%;
            left: 50%;
            transform: translateX(-50%);
            font-size: 2rem;
            font-weight: bold;
            opacity: 0;
            transition: all 0.3s ease;
            text-shadow: 2px 2px 4px var(--shadow-dark);
        }

        .score-display, .combo-display {
            position: absolute;
            top: 15px;
            font-size: 1.5rem;
            font-weight: bold;
        }
        .score-display { right: 25px; }
        .combo-display { left: 25px; }

        .controls {
            width: 100%;
            margin-top: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .neumorphic-btn, .icon-btn {
            border: none;
            border-radius: 15px;
            background: var(--bg-color);
            box-shadow: 6px 6px 12px var(--shadow-dark), -6px -6px 12px var(--shadow-light);
            color: var(--text-color);
            cursor: pointer;
            transition: all 0.1s ease-in-out;
        }
        .neumorphic-btn {
            padding: 15px 25px;
            font-size: 1rem;
            font-weight: bold;
            margin: 0 10px;
        }
        .icon-btn {
            width: 45px;
            height: 45px;
            font-size: 1.5rem;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 50%;
        }

        .neumorphic-btn:hover, .icon-btn:hover { color: var(--primary-color); }
        .neumorphic-btn:active, .icon-btn:active {
            box-shadow: inset 6px 6px 12px var(--shadow-dark), inset -6px -6px 12px var(--shadow-light);
            transform: scale(0.98);
        }
        
        input[type="file"] { display: none; }

        .modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(224, 229, 236, 0.9);
            border-radius: 30px;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            text-align: center;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        .modal.visible { opacity: 1; pointer-events: auto; }
        
        .modal-content {
            background: var(--bg-color);
            padding: 30px 40px;
            border-radius: 20px;
            box-shadow: 12px 12px 24px var(--shadow-dark), -12px -12px 24px var(--shadow-light);
            min-width: 300px;
            max-width: 90%;
        }
        .modal h2 { font-size: 2rem; margin-bottom: 20px; }
        .modal p { font-size: 1.2rem; margin-bottom: 20px; }
        
        .settings-item {
            margin-bottom: 20px;
            text-align: left;
        }
        .settings-item label {
            display: block;
            margin-bottom: 10px;
            font-weight: bold;
        }
        select, input[type="range"] {
            width: 100%;
            padding: 10px;
            border-radius: 10px;
            border: none;
            background: var(--bg-color);
            box-shadow: inset 4px 4px 8px var(--shadow-dark), inset -4px -4px 8px var(--shadow-light);
            font-family: 'Inter', sans-serif;
            color: var(--text-color);
        }
        
        .pause-menu-buttons, #difficulty-selection {
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
        }
        #difficulty-selection {
            flex-direction: row;
            justify-content: center;
        }
    </style>
</head>
<body>

    <div class="game-container">
        <div class="header">
            <button id="pause-btn" class="icon-btn" style="visibility: hidden;">❚❚</button>
            <div class="header-center">
                <h1>MIDI Groove</h1>
                <p class="song-title">Upload a MIDI file to start</p>
            </div>
            <button id="settings-btn" class="icon-btn">⚙️</button>
        </div>
        
        <div class="game-screen">
            <div class="note-lane" data-lane="0"></div>
            <div class="note-lane" data-lane="1"></div>
            <div class="note-lane" data-lane="2"></div>
            <div class="note-lane" data-lane="3"></div>
            <div class="hit-zone">
                <div class="key-target" data-lane="0">D</div>
                <div class="key-target" data-lane="1">F</div>
                <div class="key-target" data-lane="2">J</div>
                <div class="key-target" data-lane="3">K</div>
            </div>
            <div class="score-display">0</div><div class="combo-display"></div><div class="hit-feedback"></div>
        </div>
        
        <div class="controls">
            <label for="midi-upload" id="file-upload-label" class="neumorphic-btn">Upload MIDI</label>
        </div>
        <input type="file" id="midi-upload" accept=".mid,.midi">
        
        <div id="settings-modal" class="modal">
            <div class="modal-content">
                <h2>Settings</h2>
                <div class="settings-item">
                    <label for="track-select">Gameplay Track</label>
                    <select id="track-select"></select>
                </div>
                <div class="settings-item">
                    <label for="note-speed-slider">Note Speed</label>
                    <input type="range" id="note-speed-slider" min="100" max="800" value="300" step="25">
                </div>
                <div class="settings-item">
                    <label for="volume-slider">Volume</label>
                    <input type="range" id="volume-slider" min="-40" max="6" value="0" step="1">
                </div>
                <div class="settings-item">
                    <label for="hit-tolerance-slider">Hit Tolerance (100% = Normal)</label>
                    <input type="range" id="hit-tolerance-slider" min="50" max="200" value="100" step="10">
                </div>
                <div class="settings-item">
                    <label for="theme-select">Theme</label>
                    <select id="theme-select">
                        <option value="pastel">Pastel Dream</option>
                        <option value="ocean">Ocean Deep</option>
                        <option value="sunset">Sunset</option>
                    </select>
                </div>
                <div class="settings-item">
                    <label for="note-style-select">Note Style</label>
                    <select id="note-style-select">
                        <option value="rounded">Rounded</option>
                        <option value="square">Square</option>
                    </select>
                </div>
                <button id="close-settings-btn" class="neumorphic-btn">Close</button>
            </div>
        </div>
        
        <div id="difficulty-modal" class="modal">
            <div class="modal-content">
                <h2>Select Difficulty</h2>
                <p id="difficulty-song-name"></p>
                <div id="difficulty-selection">
                    <button class="neumorphic-btn difficulty-btn" data-difficulty="easy">Easy</button>
                    <button class="neumorphic-btn difficulty-btn" data-difficulty="medium">Medium</button>
                    <button class="neumorphic-btn difficulty-btn" data-difficulty="hard">Hard</button>
                </div>
                 <button id="cancel-difficulty-btn" class="neumorphic-btn" style="margin-top: 20px;">Cancel</button>
            </div>
        </div>

        <div id="pause-modal" class="modal">
             <div class="modal-content">
                <h2>Paused</h2>
                <div class="pause-menu-buttons">
                    <button id="resume-btn" class="neumorphic-btn">Resume</button>
                    <button id="restart-btn" class="neumorphic-btn">Restart Song</button>
                    <button id="change-difficulty-btn" class="neumorphic-btn">Change Difficulty</button>
                    <button id="restart-checkpoint-btn" class="neumorphic-btn" style="display:none;">Restart from Checkpoint</button>
                    <button id="main-menu-btn" class="neumorphic-btn">Main Menu</button>
                </div>
            </div>
        </div>

        <div id="results-modal" class="modal">
            <div class="modal-content">
                <h2>Game Over!</h2>
                <p id="final-score"></p><p id="final-accuracy"></p>
                <button id="play-again-btn" class="neumorphic-btn">Play Again</button>
            </div>
        </div>
    </div>

    <script>
        // --- Global Scope Variables ---
        let NOTE_COLORS = [];

        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM Elements ---
            const gameContainer = document.querySelector('.game-container');
            const gameScreen = document.querySelector('.game-screen');
            const scoreDisplay = document.querySelector('.score-display');
            const comboDisplay = document.querySelector('.combo-display');
            const hitFeedback = document.querySelector('.hit-feedback');
            const songTitle = document.querySelector('.song-title');
            const keyTargets = document.querySelectorAll('.key-target');
            const uploadInput = document.getElementById('midi-upload');
            const settingsBtn = document.getElementById('settings-btn');
            const pauseBtn = document.getElementById('pause-btn');
            
            // Modals & Buttons
            const settingsModal = document.getElementById('settings-modal');
            const closeSettingsBtn = document.getElementById('close-settings-btn');
            const difficultyModal = document.getElementById('difficulty-modal');
            const difficultyBtns = document.querySelectorAll('.difficulty-btn');
            const difficultySongName = document.getElementById('difficulty-song-name');
            const cancelDifficultyBtn = document.getElementById('cancel-difficulty-btn');
            const pauseModal = document.getElementById('pause-modal');
            const resultsModal = document.getElementById('results-modal');
            const resumeBtn = document.getElementById('resume-btn');
            const restartBtn = document.getElementById('restart-btn');
            const changeDifficultyBtn = document.getElementById('change-difficulty-btn');
            const restartCheckpointBtn = document.getElementById('restart-checkpoint-btn');
            const mainMenuBtn = document.getElementById('main-menu-btn');
            const playAgainBtn = document.getElementById('play-again-btn');
            
            // Settings
            const trackSelect = document.getElementById('track-select');
            const noteSpeedSlider = document.getElementById('note-speed-slider');
            const volumeSlider = document.getElementById('volume-slider');
            const hitToleranceSlider = document.getElementById('hit-tolerance-slider');
            const themeSelect = document.getElementById('theme-select');
            const noteStyleSelect = document.getElementById('note-style-select');
            
            // Results
            const finalScoreEl = document.getElementById('final-score');
            const finalAccuracyEl = document.getElementById('final-accuracy');

            // --- Game State & Constants ---
            let score = 0, combo = 0, totalNotes = 0, notesHit = 0;
            let midiData = null, gameActive = false, isPaused = false;
            let notesOnScreen = [], gameChart = {}, checkpoints = [];
            let currentCheckpointIndex = -1;
            let chartCache = {};
            let recentHits = [];
            let dynamicHitMultiplier = 1.0;
            let manualHitMultiplier = 1.0;
            
            const HIT_WINDOW_PERFECT = 0.08;
            const HIT_WINDOW_GOOD = 0.15;
            const NUM_LANES = 4;
            const LANE_KEYS = ['d', 'f', 'j', 'k'];
            let NOTE_SPEED = 300;
            const DIFFICULTY_SETTINGS = {
                easy: { minNoteInterval: 0.4 },
                medium: { minNoteInterval: 0.2 },
                hard: { minNoteInterval: 0.05 }
            };
            const THEMES = {
                pastel: {
                    '--bg-color': '#e0e5ec', '--primary-color': '#8a9bff', '--shadow-light': '#ffffff',
                    '--shadow-dark': '#a3b1c6', '--text-color': '#5a6779',
                    '--note-colors': '#ff8a80, #ffb347, #ffea00, #8cff80, #80d8ff, #8a9bff, #d380ff'
                },
                ocean: {
                    '--bg-color': '#2c3e50', '--primary-color': '#3498db', '--shadow-light': '#34495e',
                    '--shadow-dark': '#212f3c', '--text-color': '#ecf0f1',
                    '--note-colors': '#e74c3c, #f1c40f, #2ecc71, #3498db, #9b59b6, #1abc9c, #e67e22'
                },
                sunset: {
                    '--bg-color': '#f2d1a7', '--primary-color': '#e67e22', '--shadow-light': '#f5e6c4',
                    '--shadow-dark': '#d35400', '--text-color': '#4f2f2f',
                    '--note-colors': '#c0392b, #d35400, #f39c12, #f1c40f, #27ae60, #2980b9, #8e44ad'
                }
            };

            // --- Tone.js Setup ---
            const synth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { type: 'fmsine' },
                envelope: { attack: 0.01, decay: 0.1, sustain: 0.3, release: 1 },
            }).toDestination();
            Tone.Destination.volume.value = 0;


            // --- Event Listeners ---
            uploadInput.addEventListener('change', handleFileSelect);
            settingsBtn.addEventListener('click', () => settingsModal.classList.add('visible'));
            closeSettingsBtn.addEventListener('click', () => settingsModal.classList.remove('visible'));
            
            // Settings Listeners
            noteSpeedSlider.addEventListener('input', (e) => { NOTE_SPEED = parseInt(e.target.value); });
            volumeSlider.addEventListener('input', (e) => { Tone.Destination.volume.value = parseInt(e.target.value); });
            hitToleranceSlider.addEventListener('input', (e) => { manualHitMultiplier = parseInt(e.target.value) / 100; });
            themeSelect.addEventListener('change', (e) => applyTheme(e.target.value));
            noteStyleSelect.addEventListener('change', (e) => applyNoteStyle(e.target.value));

            // Game Flow Listeners
            difficultyBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    difficultyModal.classList.remove('visible');
                    startGame(btn.dataset.difficulty);
                });
            });
            cancelDifficultyBtn.addEventListener('click', () => difficultyModal.classList.remove('visible'));
            pauseBtn.addEventListener('click', togglePause);
            resumeBtn.addEventListener('click', togglePause);
            restartBtn.addEventListener('click', () => { pauseModal.classList.remove('visible'); startGame(); });
            changeDifficultyBtn.addEventListener('click', () => {
                pauseModal.classList.remove('visible');
                difficultyModal.classList.add('visible');
            });
            restartCheckpointBtn.addEventListener('click', restartFromCheckpoint);
            mainMenuBtn.addEventListener('click', goToMainMenu);
            playAgainBtn.addEventListener('click', () => {
                resultsModal.classList.remove('visible');
                startGame(gameChart.difficulty);
            });

            // Keyboard & Touch Listeners
            window.addEventListener('keydown', handleGlobalKeyPress);
            window.addEventListener('keyup', handleKeyRelease);
            document.querySelectorAll('.key-target').forEach(target => {
                target.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const lane = parseInt(e.target.dataset.lane);
                    processLaneHit(lane);
                    keyTargets[lane].classList.add('active');
                }, { passive: false });
                target.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    const lane = parseInt(e.target.dataset.lane);
                    keyTargets[lane].classList.remove('active');
                }, { passive: false });
            });


            // --- Core Functions ---
            
            function updateNoteColors() {
                 NOTE_COLORS = getComputedStyle(document.documentElement).getPropertyValue('--note-colors').split(',').map(c => c.trim());
            }

            function applyTheme(themeName) {
                const theme = THEMES[themeName];
                for (const [key, value] of Object.entries(theme)) {
                    document.documentElement.style.setProperty(key, value);
                }
                updateNoteColors();
            }

            function applyNoteStyle(styleName) {
                document.documentElement.style.setProperty('--note-border-radius', styleName === 'square' ? '4px' : '15px');
            }

            function handleFileSelect(event) {
                const file = event.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        midiData = new Midi(e.target.result);
                        populateTrackSelect();
                        const fileName = midiData.header.name || file.name.replace(/\.(mid|midi)$/i, '');
                        difficultySongName.textContent = fileName;
                        difficultyModal.classList.add('visible');
                    } catch (error) {
                        songTitle.textContent = "Invalid MIDI file!";
                    }
                };
                reader.readAsArrayBuffer(file);
            }

            function populateTrackSelect() {
                trackSelect.innerHTML = '<option value="-1">Auto-Select Best Track</option>';
                midiData.tracks.forEach((track, index) => {
                    if (track.notes.length > 10) {
                        const option = document.createElement('option');
                        option.value = index;
                        option.textContent = `${index}: ${track.instrument.name} (${track.notes.length} notes)`;
                        trackSelect.appendChild(option);
                    }
                });
            }

            function generateChart(midi, difficulty) {
                const cacheKey = `${midi.header.name || 'untitled'}-${trackSelect.value}-${difficulty}`;
                if (chartCache[cacheKey]) return chartCache[cacheKey];

                let bestTrack;
                const selectedTrackIndex = parseInt(trackSelect.value);
                if (selectedTrackIndex >= 0 && midi.tracks[selectedTrackIndex]) {
                    bestTrack = midi.tracks[selectedTrackIndex];
                } else {
                    const tracks = midi.tracks.filter(t => t.notes.length > 10).sort((a, b) => b.notes.length - a.notes.length);
                    const drumTrack = tracks.find(t => t.channel === 9);
                    bestTrack = drumTrack || tracks[0];
                }

                if (!bestTrack) return { chart: [], name: "No playable tracks" };

                const noteCounts = {};
                bestTrack.notes.forEach(n => { noteCounts[n.midi] = (noteCounts[n.midi] || 0) + 1; });
                const sortedNotes = Object.keys(noteCounts).sort((a, b) => noteCounts[b] - noteCounts[a]);
                const noteMap = new Map();
                sortedNotes.slice(0, NUM_LANES).forEach((midi, index) => noteMap.set(parseInt(midi), index));

                const initialChart = bestTrack.notes
                    .filter(note => noteMap.has(note.midi))
                    .map(note => ({ time: note.time, lane: noteMap.get(note.midi) }))
                    .sort((a, b) => a.time - b.time);

                const settings = DIFFICULTY_SETTINGS[difficulty];
                const lastNoteTimeInLane = new Array(NUM_LANES).fill(-Infinity);
                const chart = initialChart.filter(note => {
                    if (note.time >= lastNoteTimeInLane[note.lane] + settings.minNoteInterval) {
                        lastNoteTimeInLane[note.lane] = note.time;
                        return true;
                    }
                    return false;
                });
                
                const result = { chart, name: bestTrack.instrument.name };
                chartCache[cacheKey] = result;
                return result;
            }
            
            function generateCheckpoints(chart, duration) {
                if (duration < 90) return [];
                const checkpointTimes = [];
                for (let time = 60; time < duration - 30; time += 60) {
                    const closestNote = chart.reduce((prev, curr) => 
                        Math.abs(curr.time - time) < Math.abs(prev.time - time) ? curr : prev, {time: 0}
                    );
                    if(closestNote && closestNote.time > 0) checkpointTimes.push({ time: closestNote.time, score: 0, combo: 0, notesHit: 0 });
                }
                return checkpointTimes;
            }

            function updateCheckpoints() {
                const currentTime = Tone.Transport.seconds;
                const nextCheckpointIndex = currentCheckpointIndex + 1;
                if (nextCheckpointIndex < checkpoints.length && currentTime >= checkpoints[nextCheckpointIndex].time) {
                    currentCheckpointIndex = nextCheckpointIndex;
                    checkpoints[currentCheckpointIndex] = { ...checkpoints[currentCheckpointIndex], score, combo, notesHit };
                    restartCheckpointBtn.style.display = 'block';
                }
            }

            function restartFromCheckpoint() {
                if (currentCheckpointIndex < 0) return;
                const checkpoint = checkpoints[currentCheckpointIndex];
                score = checkpoint.score;
                combo = checkpoint.combo;
                notesHit = checkpoint.notesHit;
                scoreDisplay.textContent = score;
                updateCombo(combo);
                notesOnScreen.forEach(n => n.element.remove());
                notesOnScreen = [];
                Tone.Transport.seconds = checkpoint.time;
                togglePause();
            }

            async function startGame(difficulty, startTime = 0) {
                if (!midiData) return;
                if (!difficulty) {
                    difficulty = gameChart.difficulty || 'medium';
                }
                await Tone.start();
                resetGame();
                
                const { chart, name } = generateChart(midiData, difficulty);
                gameChart = chart;
                gameChart.difficulty = difficulty;
                if (gameChart.length === 0) {
                    songTitle.textContent = "Could not generate a playable chart!";
                    return;
                }

                checkpoints = generateCheckpoints(gameChart, midiData.duration);
                currentCheckpointIndex = -1;
                restartCheckpointBtn.style.display = 'none';

                const originalTitle = midiData.header.name || uploadInput.files[0].name.replace(/\.(mid|midi)$/i, '');
                songTitle.textContent = `${originalTitle} (${name})`;
                totalNotes = gameChart.length;
                
                gameActive = true;
                pauseBtn.style.visibility = 'visible';

                Tone.Transport.cancel();
                midiData.tracks.forEach(track => {
                    track.notes.forEach(note => {
                        const duration = Math.max(0.01, note.duration);
                        Tone.Transport.scheduleOnce(time => synth.triggerAttackRelease(note.name, duration, time, note.velocity), note.time);
                    });
                });
                gameChart.forEach(note => {
                    Tone.Draw.schedule(() => createNoteElement(note), note.time - (gameScreen.offsetHeight / NOTE_SPEED));
                });
                Tone.Transport.scheduleOnce(endGame, midiData.duration + 3);

                Tone.Transport.start(Tone.now(), startTime);
                gameLoop();
            }

            function togglePause() {
                if (!gameActive && !isPaused) return;
                isPaused = !isPaused;
                if (isPaused) {
                    gameActive = false;
                    Tone.Transport.pause();
                    pauseModal.classList.add('visible');
                    settingsBtn.style.pointerEvents = 'auto';
                } else {
                    gameActive = true;
                    Tone.Transport.start();
                    pauseModal.classList.remove('visible');
                    settingsModal.classList.remove('visible');
                    settingsBtn.style.pointerEvents = 'none';
                    gameLoop();
                }
            }
            
            function shutdownGame() {
                gameActive = false;
                isPaused = false;
                Tone.Transport.stop();
                Tone.Transport.cancel();
                pauseBtn.style.visibility = 'hidden';
                settingsBtn.style.pointerEvents = 'auto';
            }

            function endGame() {
                shutdownGame();
                finalScoreEl.textContent = `Final Score: ${score}`;
                const accuracy = totalNotes > 0 ? ((notesHit / totalNotes) * 100).toFixed(2) : 0;
                finalAccuracyEl.textContent = `Accuracy: ${accuracy}%`;
                resultsModal.classList.add('visible');
            }

            function resetGame() {
                score = 0; combo = 0; notesHit = 0; totalNotes = 0;
                scoreDisplay.textContent = 0;
                comboDisplay.textContent = '';
                document.querySelectorAll('.note').forEach(n => n.remove());
                notesOnScreen = [];
                isPaused = false;
                gameActive = false;
                recentHits = [];
                dynamicHitMultiplier = 1.0;
            }

            function goToMainMenu() {
                shutdownGame();
                resetGame();
                resultsModal.classList.remove('visible');
                pauseModal.classList.remove('visible');
                songTitle.textContent = 'Upload a MIDI file to start';
                uploadInput.value = '';
            }

            function gameLoop() {
                if (!gameActive) return;
                updateCheckpoints();

                const currentTime = Tone.Transport.seconds;
                const hitZoneTop = gameScreen.offsetHeight * 0.8; 

                notesOnScreen.forEach(note => {
                    if (note.hit) return;
                    const yPos = (currentTime - note.time) * NOTE_SPEED + hitZoneTop;
                    note.element.style.transform = `translateY(${yPos}px)`;

                    if (yPos > gameScreen.offsetHeight) {
                        note.hit = true; 
                        note.element.style.display = 'none';
                        updateCombo(0); 
                        showFeedback('Miss', '#ff8a80');
                        updateDynamicTolerance(false);
                    }
                });

                notesOnScreen = notesOnScreen.filter(note => !note.hit || note.element.style.display !== 'none');
                requestAnimationFrame(gameLoop);
            }
            
            function createNoteElement(noteInfo) {
                const noteElement = document.createElement('div');
                noteElement.classList.add('note');
                noteElement.style.top = '-50px';
                noteElement.style.left = `${25 * noteInfo.lane + 5}%`;
                noteElement.style.width = '20%';
                noteElement.style.backgroundColor = NOTE_COLORS[noteInfo.lane % NOTE_COLORS.length];
                gameScreen.appendChild(noteElement);
                noteInfo.element = noteElement;
                notesOnScreen.push(noteInfo);
            }

            function handleGlobalKeyPress(e) {
                if (e.code === 'Space' || e.code === 'Escape') {
                    e.preventDefault();
                    togglePause();
                }
                if (LANE_KEYS.includes(e.key)) {
                    processLaneHit(LANE_KEYS.indexOf(e.key));
                    keyTargets[LANE_KEYS.indexOf(e.key)].classList.add('active');
                }
            }
            
            function handleKeyRelease(e) {
                 if (LANE_KEYS.includes(e.key)) {
                    keyTargets[LANE_KEYS.indexOf(e.key)].classList.remove('active');
                 }
            }

            function processLaneHit(laneIndex) {
                if (!gameActive) return;
                let bestNote = null;
                let smallestTimeDiff = Infinity;
                const currentTime = Tone.Transport.seconds;
                const combinedMultiplier = dynamicHitMultiplier * manualHitMultiplier;

                notesOnScreen.forEach(note => {
                    if (note.lane === laneIndex && !note.hit) {
                        const timeDiff = Math.abs(currentTime - note.time);
                        if (timeDiff < smallestTimeDiff) {
                            smallestTimeDiff = timeDiff;
                            bestNote = note;
                        }
                    }
                });

                if (bestNote && smallestTimeDiff <= (HIT_WINDOW_GOOD * combinedMultiplier)) {
                    processHit(bestNote, smallestTimeDiff <= (HIT_WINDOW_PERFECT * combinedMultiplier) ? 'Perfect' : 'Good');
                }
            }

            function processHit(note, rating) {
                note.hit = true;
                note.element.style.display = 'none';
                notesHit++;
                updateDynamicTolerance(true);
                const points = rating === 'Perfect' ? 100 : 50;
                const color = rating === 'Perfect' ? '#8cff80' : '#80d8ff';
                score += points + combo;
                updateCombo(combo + 1);
                showFeedback(rating, color);
                scoreDisplay.textContent = score;
            }
            
            function updateDynamicTolerance(hit) {
                recentHits.push(hit ? 1 : 0);
                if (recentHits.length > 20) {
                    recentHits.shift();
                }

                if (recentHits.length < 10) return;

                const hitRate = recentHits.reduce((a, b) => a + b, 0) / recentHits.length;
                
                if (hitRate < 0.5) {
                    dynamicHitMultiplier = 1.5; // Very lenient
                } else if (hitRate < 0.7) {
                    dynamicHitMultiplier = 1.2; // Slightly lenient
                } else {
                    dynamicHitMultiplier = 1.0; // Normal
                }
            }

            function updateCombo(newCombo) {
                combo = newCombo;
                comboDisplay.textContent = combo > 2 ? `${combo} Combo` : '';
            }

            function showFeedback(text, color) {
                hitFeedback.textContent = text;
                hitFeedback.style.color = color;
                hitFeedback.style.opacity = 1;
                hitFeedback.style.transform = 'translateX(-50%) scale(1.2)';
                setTimeout(() => {
                    hitFeedback.style.opacity = 0;
                    hitFeedback.style.transform = 'translateX(-50%) scale(1)';
                }, 300);
            }

            // Initial setup
            updateNoteColors();
        });
    </script>
</body>
</html>